#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Standart, System and Third Party
from ipfsapi import connect
from tempfile import gettempdir, NamedTemporaryFile
import os
import json
from shutil import move

# ROS
import rospy
import rosbag

# Robonomics communication
from robonomics_msgs.msg import Offer, Demand
from ethereum_common.msg import Address, UInt256
from ethereum_common.srv import Accounts, BlockNumber
from ipfs_common.msg import Multihash, Filepath
from ipfs_common.srv import IpfsDownloadFile, IpfsDownloadFileRequest, IpfsDownloadFileResponse
from rosbag import Bag
# from ipfs_common.bag import ipfs_download

def ipfs_download_file(ipfs_client, multihash, filepath):
    file_dst = filepath
    dst_dir, dst_file = os.path.split(file_dst)

    if not os.path.isdir(dst_dir):
        try:
            os.mkdir(dst_dir)
        except Exception as e:
            rospy.logerr("Directory %s does not exists and cannot be created: %s", e)
            return False

    if os.path.isdir(file_dst):
        rospy.logwarn(
            "Collision between existed directory and IPFS downloading file destination \"%s\". Please fix it manually.",
            file_dst)
        return False

    try:
        tempdir = gettempdir()
        os.chdir(tempdir)
        ipfs_client.get(multihash)
        move(tempdir + os.path.sep + multihash, file_dst)
    except Exception as e:
        rospy.logerr("Failed to download %s to %s with exception: %s", multihash, file_dst, e)
    return True

def ipfs_download(multihash):
    tempdir = gettempdir()
    os.chdir(tempdir)

    temp_obj = NamedTemporaryFile(delete=False)

    res = ipfs_download_file(connect(), multihash.multihash, temp_obj.name)
    if not res:
        raise Exception("Can't download objective")
    messages = {}
    for topic, msg, timestamp in Bag(temp_obj.name, 'r').read_messages():
        messages[topic] = msg
    return messages


class CheckerNode:

    def __init__(self):
        rospy.init_node('checker')
        rospy.loginfo('Launching checker node...')

        rospy.wait_for_service('/eth/current_block')
        rospy.wait_for_service('/eth/accounts')
        self.accounts = rospy.ServiceProxy('/eth/accounts', Accounts)()
        rospy.loginfo(str(self.accounts))  # AIRA ethereum addresses

        rospy.Subscriber('/liability/infochan/incoming/demand',
                         Demand, self.on_incoming_demand)

        self.signing_offer = rospy.Publisher(
            '/liability/infochan/eth/signing/offer', Offer, queue_size=128)

        rospy.loginfo('Checker node is ready!')

    def act(self, incoming):
        objective_bag = ipfs_download(incoming.objective)

        log_data = self.extract_log(objective_bag['/log'].data)
        rospy.loginfo("Logdata {}".format(log_data))

        ''' CHECK THE LOG FILE
        for row in log_data["rows"]:
            rospy.loginfo("Checking '{}'".format(row))
            pass # TODO
        '''

        rospy.loginfo("Looks good! Publishing a demand message")
        self.make_offer(incoming)

    def extract_log(self, ipfs_hash):
        rospy.loginfo("Downloading log: {}".format(ipfs_hash))

        tempdir = gettempdir()
        os.chdir(tempdir)

        temp_log = NamedTemporaryFile(delete=False)

        rospy.wait_for_service('/ipfs/get_file')
        get_file = rospy.ServiceProxy('/ipfs/get_file', IpfsDownloadFile)

        multihash = Multihash(ipfs_hash)
        file_path = Filepath(temp_log.name)
        request = IpfsDownloadFileRequest(ipfs_address=multihash, file=file_path)
        response = get_file(request)

        if response.success:
            with open(temp_log.name, 'r') as f:
                return json.loads(f.read())

        # TODO raise exception

    def on_incoming_demand(self, incoming: Demand):
        rospy.loginfo('Incoming demand %s...', str(incoming))
        if (incoming.model.multihash == rospy.get_param('~model') and incoming.token.address == rospy.get_param('~token')):
            rospy.loginfo('For my model and token!')
            self.act(incoming)  # reactive strategy
        else:
            rospy.loginfo('Not fits my model or token, skip it.')

    def make_deadline(self):
        lifetime = int(rospy.get_param('~order_lifetime'))
        deadline = rospy.ServiceProxy(
            '/eth/current_block', BlockNumber)().number + lifetime
        return str(deadline)

    def make_offer(self, incoming):
        rospy.loginfo('Making offer...')

        offer = Offer()
        offer.model = Multihash()
        offer.model.multihash = rospy.get_param('~model')
        offer.objective = incoming.objective
        offer.token = Address()
        offer.token.address = rospy.get_param('~token')
        offer.cost = incoming.cost
        offer.lighthouse = Address()
        offer.lighthouse.address = rospy.get_param('~lighthouse')
        offer.validator = Address()
        offer.validator.address = rospy.get_param('~validator')
        offer.lighthouseFee = UInt256()
        offer.lighthouseFee.uint256 = '0'
        offer.deadline = UInt256()
        offer.deadline.uint256 = self.make_deadline()

        self.signing_offer.publish(offer)
        rospy.loginfo(offer)

    def spin(self):
        rospy.spin()


if __name__ == '__main__':
    CheckerNode().spin()

