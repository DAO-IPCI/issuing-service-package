#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Standart, System and Third party
from collections import namedtuple
from queue import Queue
from threading import Thread

# ROS
import rospy
from std_msgs.msg import String

# AIRA
from robonomics_liability.msg import Liability
from robonomics_liability.srv import StartLiability, FinishLiability

# Web3
from web3 import Web3, HTTPProvider
from eth_keys import keys

import psycopg2
import sys
import json


class WorkerNode:
    '''
      You need a queue to store any new liabilities while the CPS performs a task
    '''
    liability_queue = Queue()
    in_process = False

    # TODO: need an objective messages collector and empty objective (by new liability) starter
    def __init__(self):
        rospy.init_node('worker')
        rospy.loginfo('Launching worker node...')

        rospy.Subscriber('/liability/ready', Liability, self.on_new_liability)
        rospy.Subscriber('next_liability', Liability, self.subscribe_and_start)

        self.next_liability = rospy.Publisher(
            'next_liability', Liability, queue_size=128)

        rospy.wait_for_service('liability/finish')

        self.liability_proxy = namedtuple('liability_srvs_proxy', ['start', 'finish'])(
            rospy.ServiceProxy('liability/start', StartLiability),
            rospy.ServiceProxy('liability/finish', FinishLiability))

        try:
            # Put user name, password etc
            self.connection = psycopg2.connect(
                user="", password="", host="", port="", database="")
            cursor = self.connection.cursor()
            # Print PostgreSQL Connection properties
            print(self.connection.get_dsn_parameters(), "\n")
            # Print PostgreSQL version
            cursor.execute("SELECT version();")
            record = cursor.fetchone()
            print("You are connected to - ", record, "\n")

        except (Exception, psycopg2.Error) as error:
            print("Error while connecting to PostgreSQL", error)
            sys.exit()

        web3_http_provider = rospy.get_param('~web3_http_provider')
        http_provider = HTTPProvider(web3_http_provider)
        self.web3 = Web3(http_provider)
        self.token_contract = rospy.get_param('~token_contract')
        self.token_contract_abi = json.loads(
            rospy.get_param('~token_contract_abi'))

        with open(rospy.get_param('~keyfile'), 'r') as f:
            word = f.readline().strip()
            pk = keys.PrivateKey(Web3.toBytes(hexstr=word))
            self.eth_address = pk.public_key.to_checksum_address()
            self.private_key = pk.to_hex()

        rospy.loginfo('Worker node launched.')

    def on_new_liability(self, msg):
        self.liability_queue.put(msg)
        rospy.loginfo("Got new liability %s", msg.address)

    def _process_liability_queue(self):
        while not rospy.is_shutdown() and not self.in_process:
            msg = self.liability_queue.get()
            self.next_liability.publish(msg)

    def subscribe_and_start(self, liability):
        rospy.loginfo('Starting process...')

        prefix = '/liability/eth_' + liability.address.address
        pub = rospy.Publisher(prefix + '/data', String, queue_size=128)
        promisee = liability.promisee.address

        def callback(task):
            # rospy.loginfo('Got new tast: %s', task)

            rospy.loginfo("Collecting data...")

            cursor = self.connection.cursor()
            cursor.execute("SELECT measure FROM solar;")

            rospy.loginfo("Got {} rows...".format(cursor.rowcount))

            last = 0
            for item in cursor:
                line = item[0]
                try:
                    obj = json.loads(line)
                    last = obj['children'][0]['parameter'][1]['value']['doubleValue']
                    pub.publish(String(data=line))
                except ValueError as e:
                    print("{} {}".format(e, line))

            rospy.loginfo('Issuing {} sertificates...'.format(last))

            contract = self.web3.eth.contract(
                address=self.token_contract, abi=self.token_contract_abi)
            nonce = self.web3.eth.getTransactionCount(self.eth_address)

            transfer_txn = contract.functions.mint(promisee, int(last * 1000)).buildTransaction({
                'chainId': 4451,
                'gas': 70000,
                'gasPrice': self.web3.toWei('0', 'gwei'),
                'nonce': nonce,
            })

            signed_txn = self.web3.eth.account.signTransaction(
                transfer_txn, self.private_key)

            tx_hash = self.web3.eth.sendRawTransaction(
                signed_txn.rawTransaction)
            print("Tx hash {}".format(tx_hash.hex()))

            # TODO TODO
            rospy.sleep(5)

            self.liability_proxy.finish(liability.address.address, True)
            rospy.loginfo('Process complete.')
            self.in_process = False
        rospy.Subscriber(prefix + '/task', String, callback)

        self.in_process = True
        self.liability_proxy.start(liability.address.address)

    def spin(self):
        Thread(target=self._process_liability_queue, daemon=True).start()
        rospy.spin()


if __name__ == '__main__':
    WorkerNode().spin()
