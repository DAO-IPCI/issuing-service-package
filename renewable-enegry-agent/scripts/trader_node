#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Standart, System and Third Party

# ROS
import rospy
from std_srvs.srv import Empty

# Robonomics communication
from robonomics_msgs.msg import Offer, Demand
from ethereum_common.msg import Address, UInt256
from ethereum_common.srv import Accounts, BlockNumber
from ipfs_common.msg import Multihash


class TraderNode:

    def __init__(self):
        rospy.init_node('trader')
        rospy.loginfo('Launching trader node...')

        rospy.wait_for_service('/eth/current_block')
        rospy.wait_for_service('/eth/accounts')
        self.accounts = rospy.ServiceProxy('/eth/accounts', Accounts)()
        rospy.loginfo(str(self.accounts))  # AIRA ethereum addresses

        self.signing_demand = rospy.Publisher(
            '/liability/infochan/eth/signing/demand', Demand, queue_size=128)

        rospy.Service('make_demand', Empty, self.act)

        rospy.Subscriber('/liability/infochan/incoming/demand',
                         Demand, self.on_incoming_demand)
        rospy.Subscriber('/liability/infochan/incoming/offer',
                         Offer, self.on_incoming_offer)

        rospy.loginfo('Trader node launched.')

    def act(self):
        self.make_demand(rospy.get_param('~objective'), 0)

    def on_incoming_demand(self, incoming: Demand):
        rospy.loginfo('Incoming demand %s...', str(incoming))
        if (incoming.model.multihash == rospy.get_param('~model') and incoming.token.address == rospy.get_param('~token')):
            rospy.loginfo('For my model and token!')
            self.act(incoming)  # reactive strategy
        else:
            rospy.loginfo('Not fits my model or token, skip it.')

    def on_incoming_offer(self, incoming: Offer):
        rospy.loginfo('Incoming offer %s...', str(incoming))
        if (incoming.model.multihash == rospy.get_param('~model') and incoming.token.address == rospy.get_param('~token')):
            rospy.loginfo('For my model and token!')
            self.act(incoming)  # reactive strategy
        else:
            rospy.loginfo('Not fits my model or token, skip it.')

    def make_deadline(self):
        lifetime = int(rospy.get_param('~order_lifetime'))
        deadline = rospy.ServiceProxy(
            '/eth/current_block', BlockNumber)().number + lifetime
        return str(deadline)

    def make_demand(self, objective, cost):
        rospy.loginfo('Making demand...')

        demand = Demand()
        demand.model = Multihash()
        demand.model.multihash = rospy.get_param('~model')
        demand.objective = objective
        demand.token = Address()
        demand.token.address = rospy.get_param('~token')
        demand.cost = cost
        demand.validatorFee = UInt256()
        demand.validatorFee.uint256 = '0'
        demand.validator = Address()
        demand.validator.address = rospy.get_param('~validator')
        demand.deadline = UInt256()
        demand.deadline.uint256 = self.make_deadline()

        self.signing_demand.publish(demand)
        rospy.loginfo(demand)

    def spin(self):
        rospy.spin()


if __name__ == '__main__':
    TraderNode().spin()
